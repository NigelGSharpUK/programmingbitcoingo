package ecc

import (
	"fmt"
	"math/big"
)

type CurveParams struct {
	a  big.Int // Parameter of the elliptic curve y^2 = x^3 + ax + b
	b  big.Int // Parameter of the elliptic curve y^2 = x^3 + ax + b
	p  big.Int // Order of the Finite Fields (must be prime)
	Gx big.Int // X coordinate of the Generator point G
	Gy big.Int // Y coordinate of the Generator point G
	n  big.Int // The order of the group generated by G
}

// Bitcoin uses a particular elliptic curve over finite fields, called secp256k1.
// Here are the paramenters of secp256k1
func secp256k1_Params() *CurveParams {
	params := new(CurveParams)

	params.a.SetInt64(0)
	params.b.SetInt64(7)

	// p = 2^256 - 2^32 - 977
	var p2_256 big.Int
	p2_256.Exp(big.NewInt(2), big.NewInt(256), nil)
	var p2_32 big.Int
	p2_32.Exp(big.NewInt(2), big.NewInt(32), nil)
	var diffPowers2 big.Int
	diffPowers2.Sub(&p2_256, &p2_32)
	params.p.Sub(&diffPowers2, big.NewInt(977))

	// Gx = a big hex number
	params.Gx.SetString("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", 16)
	// Gy = a big hex number
	params.Gy.SetString("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", 16)
	// n = a big hex number
	params.n.SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)
	return params
}

type FieldElement struct {
	num   big.Int
	prime big.Int
}

func NewFieldElement(num int64, prime int64) *FieldElement {
	numBig := big.NewInt(num)
	primeBig := big.NewInt(prime)
	return NewFieldElementBig(numBig, primeBig)
}

func NewFieldElementBig(num *big.Int, prime *big.Int) *FieldElement {
	if num.Cmp(prime) >= 0 || num.Cmp(big.NewInt(0)) == -1 {
		panic("num must be between 0 and prime-1 inclusive")
	}
	fe := new(FieldElement)
	fe.num.Set(num)
	fe.prime.Set(prime)
	return fe
}

func NewS256Field(num *big.Int) *FieldElement {
	params := secp256k1_Params()
	return NewFieldElementBig(num, &params.p)
}

func NewS256Point(x *big.Int, y *big.Int) *Point {
	params := secp256k1_Params()
	x_fe := NewFieldElementBig(x, &params.p)
	y_fe := NewFieldElementBig(y, &params.p)
	a_fe := NewFieldElementBig(&params.a, &params.p)
	b_fe := NewFieldElementBig(&params.b, &params.p)
	return NewPoint(x_fe, y_fe, a_fe, b_fe)
}

func NewS256InfPoint() *Point {
	params := secp256k1_Params()
	a_fe := NewFieldElementBig(&params.a, &params.p)
	b_fe := NewFieldElementBig(&params.b, &params.p)
	return NewInfPoint(a_fe, b_fe)
}

func G() *Point {
	params := secp256k1_Params()
	Gx_fe := NewFieldElementBig(&params.Gx, &params.p)
	Gy_fe := NewFieldElementBig(&params.Gy, &params.p)
	a_fe := NewFieldElementBig(&params.a, &params.p)
	b_fe := NewFieldElementBig(&params.b, &params.p)
	return NewPoint(Gx_fe, Gy_fe, a_fe, b_fe)
}

func (fe *FieldElement) Repr() string {
	primeOrder := ""
	if fe.prime.Cmp(&secp256k1_Params().p) == 0 {
		primeOrder = "secp256k1"
	} else {
		primeOrder = fmt.Sprintf("%d", &fe.prime)
	}
	val := ""
	if fe.num.Cmp(big.NewInt(65536)) == -1 {
		val = fmt.Sprintf("%d", &fe.num) // Small numbers as decimal
	} else {
		val = fmt.Sprintf("%064X", &fe.num) // Big numbers as 256 bit hex
	}
	return "FieldElement_" + primeOrder + "(" + val + ")"
}

// Test for equality
func (fe *FieldElement) Eq(other *FieldElement) bool {
	if fe == nil || other == nil {
		panic("Cannot compare nil pointers")
	}
	//return fe.num == other.num && fe.prime == other.prime
	return fe.num.Cmp(&other.num) == 0 && fe.prime.Cmp(&other.prime) == 0
}

// Now implements interface similar in style to big.Int
func (z *FieldElement) Add(x, y *FieldElement) *FieldElement {
	if z == nil {
		panic("Cannot write to nil pointer")
	}
	if x == nil || y == nil {
		panic("Cannot add nil pointers")
	}
	if x.prime.Cmp(&y.prime) != 0 {
		panic("Cannot add two numbers in different Fields")
	}
	var sum big.Int
	sum.Add(&x.num, &y.num)
	z.num.Mod(&sum, &x.prime) // [  ] I think this is OK - Euclidean Modulus unlike Go
	z.prime.Set(&x.prime)
	return z
}

// Now implements interface similar in style to big.Int
func (z *FieldElement) Sub(x, y *FieldElement) *FieldElement {
	//panic("Not Implemented")

	// Answer Exercise 3
	if z == nil {
		panic("Cannot write to nil pointer")
	}
	if x == nil || y == nil {
		panic("Cannot subtract nil pointers")
	}
	if x.prime.Cmp(&y.prime) != 0 {
		panic("Cannot subtract two numbers in different Fields")
	}
	//num := (x.num - y.num) % x.prime
	var diff big.Int
	diff.Sub(&x.num, &y.num)
	z.num.Mod(&diff, &x.prime)
	z.prime.Set(&x.prime)
	return z
}

// Now implements interface similar in style to big.Int
func (z *FieldElement) Mul(x, y *FieldElement) *FieldElement {
	//panic("Not Implemented")

	// Answer Exercise 6
	if z == nil {
		panic("Cannot write to nil pointer")
	}
	if x == nil || y == nil {
		panic("Cannot multiply nil pointers")
	}
	//if fe.prime != other.prime {
	if x.prime.Cmp(&y.prime) != 0 {
		panic("Cannot multiply two numbers in different Fields")
	}
	//num := x.num * y.num % x.prime
	var prod big.Int
	prod.Mul(&x.num, &y.num)
	z.num.Mod(&prod, &x.prime)
	z.prime.Set(&x.prime)
	return z
}

func (fe *FieldElement) Pow(exp *big.Int) *FieldElement {
	//n := Mod(exp, (fe.prime - 1))		[  ] Really? -1?
	var primeMinusOne big.Int
	primeMinusOne.Sub(&fe.prime, big.NewInt(1))
	var n big.Int
	n.Mod(exp, &primeMinusOne)
	//num := PowMod(fe.num, n, fe.prime)
	var num big.Int
	num.Exp(&fe.num, &n, &fe.prime)
	return NewFieldElementBig(&num, &fe.prime)
}

func (fe *FieldElement) Div(other *FieldElement) *FieldElement {
	//panic("Not Implemented")

	// Answer Exercise 9
	if fe == nil || other == nil {
		panic("Cannot divide nil pointers")
	}
	//if fe.prime != other.prime {
	if fe.prime.Cmp(&other.prime) != 0 {
		panic("Cannot divide two numbers in different Fields")
	}
	// Using Fermat's Little Theorem
	//num := Mod(fe.num*PowMod(other.num, fe.prime-2, fe.prime), fe.prime)
	var pMinusTwo big.Int
	pMinusTwo.Sub(&fe.prime, big.NewInt(2))
	var numToPMinusTwo big.Int
	numToPMinusTwo.Exp(&other.num, &pMinusTwo, &fe.prime)
	var product big.Int
	product.Mul(&fe.num, &numToPMinusTwo)
	var num big.Int
	num.Mod(&product, &fe.prime)
	return NewFieldElementBig(&num, &fe.prime)
}

func (fe *FieldElement) Rmul(coefficient *big.Int) *FieldElement {
	//num := Mod(fe.num*coefficient, fe.prime)
	var product big.Int
	product.Mul(&fe.num, coefficient)
	var num big.Int
	num.Mod(&product, &fe.prime)
	return NewFieldElementBig(&num, &fe.prime)
}

func (fe *FieldElement) Set(other *FieldElement) *FieldElement {
	fe.num = other.num
	fe.prime = other.prime
	return fe
}

type Point struct {
	isInf bool
	x     FieldElement // ignore if isInf
	y     FieldElement // ignore if isInf
	a     FieldElement
	b     FieldElement
}

func NewPoint(x, y, a, b *FieldElement) *Point {
	res := new(Point)
	res.isInf = false
	res.x.Set(x)
	res.y.Set(y)
	res.a.Set(a)
	res.b.Set(b)
	//if y^2 != x^3 + ax + b
	lhs := y.Pow(big.NewInt(2))
	xcubed := x.Pow(big.NewInt(3))
	var ax FieldElement
	ax.Mul(a, x)
	var xCubedPlusAx FieldElement
	xCubedPlusAx.Add(xcubed, &ax)
	var rhs FieldElement
	rhs.Add(&xCubedPlusAx, b)
	if !lhs.Eq(&rhs) {
		panic("Point is not on the curve")
	}
	return res
}

func NewInfPoint(a, b *FieldElement) *Point {
	res := new(Point)
	res.isInf = true
	res.a.Set(a)
	res.b.Set(b)
	return res
}

func (p *Point) Set(other *Point) *Point {
	p.isInf = other.isInf
	p.x = other.x
	p.y = other.y
	p.a = other.a
	p.b = other.b
	return p
}

func (p *Point) Eq(other *Point) bool {
	// First check for both infinities
	if p.isInf && other.isInf {
		return p.a.Eq(&other.a) && p.b.Eq(&other.b)
	}
	// Then check for one or other infinities
	if p.isInf || other.isInf {
		// We know they're not both infinity
		return false
	}
	// Now we're safe to compare FiniteFields
	return p.x.Eq(&other.x) && p.y.Eq(&other.y) && p.a.Eq(&other.a) && p.b.Eq(&other.b)
}

func (p *Point) Repr() string {
	if p.isInf {
		return "Point(infinity)"
	}
	// Print over two lines
	return "Point(" + p.x.Repr() + ",\n      " + p.y.Repr() + ")_" + p.a.Repr() + "_" + p.b.Repr()
}

func (p *Point) Rmul(coefficient *big.Int) *Point {
	// If order of FieldElement is Bitcoin's p, then we can assume a value for n,
	// which we can use to increase efficiency by modding by n
	// HACK - assumes we never want to use the same p as Bitcoin's p other than when dealing with Bitcoin
	params := secp256k1_Params()
	var order big.Int
	order.Set(&p.x.prime)
	var coef big.Int
	if order.Cmp(&params.p) == 0 {
		coef.Mod(coefficient, &params.n)
	} else {
		coef.Set(coefficient)
	}

	var current Point
	current.Set(p)

	result := NewInfPoint(&p.a, &p.b) // Point at infinity acts as zero
	//for coef != 0 {
	for coef.Cmp(big.NewInt(0)) != 0 {
		//if coef&1 == 1 {
		var lsb big.Int
		lsb.And(&coef, big.NewInt(1))
		if lsb.Cmp(big.NewInt(1)) == 0 {
			result = result.Add(&current)
		}
		current.Set(current.Add(&current))
		//coef >>= 1
		coef.Rsh(&coef, 1)
	}
	return result
}

func (p *Point) Add(other *Point) *Point {
	if !p.a.Eq(&other.a) || !p.b.Eq(&other.b) {
		panic("Can't add points that are not on same curve")
	}
	var result Point
	if p.isInf {
		// If p is point at infinity, it is the identity under addition
		result.Set(other)
		return &result
	}
	if other.isInf {
		// If other is point at infinity, it is the identity under addition
		result.Set(p)
		return &result
	}

	// Handle p==other and y==0 (vertical tangent)
	//if p.Eq(other) && p.y.num == 0 {
	if p.Eq(other) && p.y.num.Cmp(big.NewInt(0)) == 0 { // [  ] Is this the zero that is meant?
		return NewInfPoint(&p.a, &p.b)
	}

	// Case 1: self.x == other.x, self.y != other.y
	// Result is point at infinity
	// panic("Not implemented")

	// Answer Exercise 3
	if p.x.Eq(&other.x) && !p.y.Eq(&other.y) {
		return NewInfPoint(&p.a, &p.b)
	}

	// Case 2: self.x â‰  other.x
	// Formula (x3,y3)==(x1,y1)+(x2,y2)
	// s=(y2-y1)/(x2-x1)
	// x3=s**2-x1-x2
	// y3=s*(x1-x3)-y1
	if !p.x.Eq(&other.x) {
		// panic( "Not implemented")

		// Answer Exercise 5
		var ydiff FieldElement
		ydiff.Sub(&other.y, &p.y)
		var xdiff FieldElement
		xdiff.Sub(&other.x, &p.x)
		s := ydiff.Div(&xdiff)

		ssquared := s.Pow(big.NewInt(2))
		var ssquaredMinusX1 FieldElement
		ssquaredMinusX1.Sub(ssquared, &p.x)
		var x3 FieldElement
		x3.Sub(&ssquaredMinusX1, &other.x)

		var x1MinusX3 FieldElement
		x1MinusX3.Sub(&p.x, &x3)
		var sTimesX1MinusX3 FieldElement
		sTimesX1MinusX3.Mul(s, &x1MinusX3)
		var y3 FieldElement
		y3.Sub(&sTimesX1MinusX3, &p.y)

		return NewPoint(&x3, &y3, &p.a, &p.b)
	}

	// Case 3: self == other
	// Formula (x3,y3)=(x1,y1)+(x1,y1)
	// s=(3*x1**2+a)/(2*y1)
	// x3=s**2-2*x1
	// y3=s*(x1-x3)-y1
	// panic("Not implemented")

	// Answer Exercise 7
	// Handle p,other being same point, so use tangent
	if p.x.Eq(&other.x) && p.y.Eq(&other.y) {
		x1squaredTimesThree := p.x.Pow(big.NewInt(2)).Rmul(big.NewInt(3))
		var x1squaredTimesThreePlusA FieldElement
		x1squaredTimesThreePlusA.Add(x1squaredTimesThree, &p.a)
		s := x1squaredTimesThreePlusA.Div(p.y.Rmul(big.NewInt(2)))

		ssquared := s.Pow(big.NewInt(2))
		twox1 := p.x.Rmul(big.NewInt(2))
		var x3 FieldElement
		x3.Sub(ssquared, twox1)

		var x1MinusX3 FieldElement
		x1MinusX3.Sub(&p.x, &x3)
		var sTimesX1MinusX3 FieldElement
		sTimesX1MinusX3.Mul(s, &x1MinusX3)
		var y3 FieldElement
		y3.Sub(&sTimesX1MinusX3, &p.y)

		return NewPoint(&x3, &y3, &p.a, &p.b)
	}

	// Final case, tangent is vertical
	if p.x.Eq(&other.x) && p.y.num.Cmp(big.NewInt(0)) == 0 { // [  ] Is this what's really meant by "y is zero"
		return NewInfPoint(&p.a, &p.b)
	}

	panic("Fell through, missing case?")
}
