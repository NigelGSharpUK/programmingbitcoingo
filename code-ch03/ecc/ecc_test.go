package ecc

import (
	"math/big"
	"testing"
)

func TestNe(t *testing.T) {
	a := NewFieldElement_(2, 31)
	b := NewFieldElement_(2, 31)
	c := NewFieldElement_(15, 31)
	if !a.Eq(b) {
		t.Fail()
	}
	if !a.Ne(c) {
		t.Fail()
	}
	if a.Ne(b) {
		t.Fail()
	}
}

func TestAdd(t *testing.T) {
	a := NewFieldElement_(2, 31)
	b := NewFieldElement_(15, 31)
	if a.Add(b).Ne(NewFieldElement_(17, 31)) {
		t.Fail()
	}
	a = NewFieldElement_(17, 31)
	b = NewFieldElement_(21, 31)
	if a.Add(b).Ne(NewFieldElement_(7, 31)) {
		t.Fail()
	}
}

func TestSub(t *testing.T) {
	a := NewFieldElement_(29, 31)
	b := NewFieldElement_(4, 31)
	if a.Sub(b).Ne(NewFieldElement_(25, 31)) {
		t.Fail()
	}
	a = NewFieldElement_(15, 31)
	b = NewFieldElement_(30, 31)
	if a.Sub(b).Ne(NewFieldElement_(16, 31)) {
		t.Fail()
	}
}

func TestMul(t *testing.T) {
	a := NewFieldElement_(24, 31)
	b := NewFieldElement_(19, 31)
	if a.Mul(b).Ne(NewFieldElement_(22, 31)) {
		t.Fail()
	}
}

func TestPow(t *testing.T) {
	a := NewFieldElement_(17, 31)
	if a.Pow(big.NewInt(3)).Ne(NewFieldElement_(15, 31)) {
		t.Fail()
	}
	a = NewFieldElement_(5, 31)
	b := NewFieldElement_(18, 31)
	if a.Pow(big.NewInt(5)).Mul(b).Ne(NewFieldElement_(16, 31)) {
		t.Fail()
	}
}

func TestDiv(t *testing.T) {
	a := NewFieldElement_(3, 31)
	b := NewFieldElement_(24, 31)
	if a.Div(b).Ne(NewFieldElement_(4, 31)) {
		t.Fail()
	}
	a = NewFieldElement_(17, 31)
	if a.Pow(big.NewInt(-3)).Ne(NewFieldElement_(29, 31)) {
		t.Fail()
	}
	a = NewFieldElement_(4, 31)
	b = NewFieldElement_(11, 31)
	if a.Pow(big.NewInt(-4)).Mul(b).Ne(NewFieldElement_(13, 31)) {
		t.Fail()
	}
}

/*
// These test are no longer valid now that NewPoint takes FieldElements
func TestPointNe(t *testing.T) {
	a := NewPoint(3, 7, 5, 7)
	b := NewPoint(18, 77, 5, 7)
	if a.ne(b) == false {
		t.Fail()
	}
	if a.ne(a) {
		t.Fail()
	}
}

func TestPointAdd0(t *testing.T) {
	a := NewInfPoint(5, 7)
	b := NewPoint(2, 5, 5, 7)
	c := NewPoint(2, -5, 5, 7)
	if a.add(b).ne(b) {
		t.Fail()
	}
	if b.add(a).ne(b) {
		t.Fail()
	}
	if b.add(c).ne(a) {
		t.Fail()
	}
}

func TestPointAdd1(t *testing.T) {
	a := NewPoint(3, 7, 5, 7)
	b := NewPoint(-1, -1, 5, 7)
	if a.add(b).ne(NewPoint(2, -5, 5, 7)) {
		t.Fail()
	}
}

func TestPointAdd2(t *testing.T) {
	a := NewPoint(-1, -1, 5, 7)
	if a.add(a).ne(NewPoint(18, 77, 5, 7)) {
		t.Fail()
	}
}
*/

func TestEccTestOnCurve(t *testing.T) {
	prime := 223
	a := NewFieldElement_(0, prime)
	b := NewFieldElement_(7, prime)
	//https://golang.org/ref/spec#Composite_literals
	valid_points := [][]int{{192, 105}, {17, 56}, {1, 193}}
	//invalid_points := [][]int{{200, 119}, {42, 99}}
	for _, point := range valid_points {
		x := NewFieldElement_(point[0], prime)
		y := NewFieldElement_(point[1], prime)
		p := NewPoint(x, y, a, b)
		println(p.Repr())
	}
}

// Answer Exercise 3
func TestEccAdd(t *testing.T) {
	prime := 223
	a := NewFieldElement_(0, prime)
	b := NewFieldElement_(7, prime)
	p1 := NewPoint(NewFieldElement_(170, prime), NewFieldElement_(142, prime), a, b)
	p2 := NewPoint(NewFieldElement_(60, prime), NewFieldElement_(139, prime), a, b)
	sum := NewPoint(NewFieldElement_(220, prime), NewFieldElement_(181, prime), a, b)
	if p1.Add(p2).Ne(sum) {
		t.Fail()
	}
	p1 = NewPoint(NewFieldElement_(47, prime), NewFieldElement_(71, prime), a, b)
	p2 = NewPoint(NewFieldElement_(17, prime), NewFieldElement_(56, prime), a, b)
	sum = NewPoint(NewFieldElement_(215, prime), NewFieldElement_(68, prime), a, b)
	if p1.Add(p2).Ne(sum) {
		t.Fail()
	}
	p1 = NewPoint(NewFieldElement_(143, prime), NewFieldElement_(98, prime), a, b)
	p2 = NewPoint(NewFieldElement_(76, prime), NewFieldElement_(66, prime), a, b)
	sum = NewPoint(NewFieldElement_(47, prime), NewFieldElement_(71, prime), a, b)
	if p1.Add(p2).Ne(sum) {
		t.Fail()
	}
}

// We must be able to compare with inf (we found that we couldn't at first!)
func TestInfCompare(t *testing.T) {
	prime := 223
	a := NewFieldElement_(0, prime)
	b := NewFieldElement_(7, prime)
	infx := NewInfPoint(a, b)
	infy := NewInfPoint(a, b)
	if infx.Ne(infy) {
		t.Fail()
	}
	x := NewFieldElement_(15, prime)
	y := NewFieldElement_(86, prime)
	z := NewPoint(x, y, a, b)
	if infx.Eq(z) {
		t.Fail()
	}
	if z.Eq(infy) {
		t.Fail()
	}
}

func TestBitcoinParams(t *testing.T) {
	// Verify Gx,Gy are on the curve y^2 = x^3 +ax +b (with a,b = 0,7)
	bitcoinParams := secp256k1_Params()
	Gx := bitcoinParams.Gx
	Gy := bitcoinParams.Gy
	a := bitcoinParams.a
	b := bitcoinParams.b
	p := bitcoinParams.p
	var ysquared big.Int
	ysquared.Exp(Gy, big.NewInt(2), p)
	var xcubed big.Int
	xcubed.Exp(Gx, big.NewInt(3), p)
	var ax big.Int
	ax.Mul(a, Gx)
	lhsModP := ysquared // Already Mod'd by the parameter p in Exp() above
	var xcubedPlusAx big.Int
	xcubedPlusAx.Add(&xcubed, &ax)
	var rhs big.Int
	rhs.Add(&xcubedPlusAx, b)
	var rhsModP big.Int
	rhsModP.Mod(&rhs, p)
	//fmt.Printf("0x%064X\n", &lhsModP)
	//fmt.Printf("0x%064X\n", &rhsModP)
	if lhsModP.Cmp(&rhsModP) != 0 {
		t.Fail()
	}

	// Verify the order of the group generated by point Gx,Gy is n
	G := G()                  // Bitcoin's generator point
	n := secp256k1_Params().n // Bitcoin's order of the group generated by G
	inf := G.Rmul(n)          // Should be the zero point (at infinity)
	if inf.Ne(NewS256InfPoint()) {
		t.Fail()
	}
}
